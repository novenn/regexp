---
layout: layout
---


不要搞又臭又长的字符匹配，不要搞乱七八糟的判断逻辑。搞来搞去，不如用正则。

你可以直接套用下面的一些经典案例，如果你想修改它们，你还需要了解一些[正则表达式的基础知识](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)。

#### 从URL中提取文件名

```
const pattern = /([^\/]*)$/;
const url = "https://www.test.com/to/path/regexp.html";

const result = url.match(pattern); // ['regexp.html', 'regexp.html', index: 29....]
```

*分析：URL中文件名的位置比较特殊，是最后一个`/`到字符串结尾的内容，因为文件名的格式要求比较宽松，可能包含的字符比较多，这里直接使用反选的方法，只要不包含`/`即可。`([^\/]*)`表示匹配除了`/`的任意字符，注意要加上`$`结尾匹配符，否则提取出来的不是最末尾位置的内容。*


#### 从一堆地址中提取出包含南京路的城市名<a id="forward"></a>
```
const pattern = /([^省]*市)(?=.*南京路)/
const address = [
  "四川省成都市龙泉驿区南京路318号",
  "广东省广州市荔湾区南京路14号大院",
  "天府三街海底捞店南京路厅",
  "湖北省南京路888号02栋408室",
  "北京市海淀区上地三街东口",
  "上海市黄浦区河南中路与南京路交口"
]

const result = address.map(item => item.match(pattern)?.[0])  // ['成都市', '广州市', '上海市']
                      .filter(item => item);              
```
*分析：本例使用到**正向肯定预查**，正向肯定预查指的是：在给定字符串中匹配一个目标子字符串，其成功的条件是必须同时匹配两个子表达式，一个是目标字符串子表达式，本例中的`([^省]*市)`，另一个是预查子表达式,本例中的`(?=.*南京路)`，并且预查表达式只能匹配目标字符串之后的字符。通俗的讲，就是匹配目标子表达式的同时要预判一下在给定字符串中目标子字符串之后的字符串是否匹配另一个表达式。*<br />
*那就有人说了，直接`([^省]*市).*南京路`不就能实现？用啥正向肯定预查，费劲巴拉。因为预查表达式是**零宽的**，查看[验证密码](#password)的例子*

相关概念：
|概念|语法|说明|示例|
|-|-|-|-|
|正向肯定预查|(?=abc)|匹配目标子表达式的同时要预判一下<br />在给定字符串中目标子字符串之后的剩余字符串<br>是否匹配另一个表达式。|如上|
|正向否定预查|(?!abc)|匹配目标子表达式的同时要预判一下<br />在给定字符串中目标子字符串之后的剩余字符串<br>是否不能匹配另一个表达式。|提取出不包含南京路的城市名<br>`/([^省]*市)(?!.*南京路)/`|
|负向肯定预查|(?<=abc)|匹配目标子表达式的同时要预判一下<br />在给定字符串中目标子字符串之前的字符串<br>是否匹配另一个表达式。|提取出属于四川省的城市<br>`/(?<=四川省.*)(.*市)/`|
|负向否定预查|(?<!abc)|匹配目标子表达式的同时要预判一下<br />在给定字符串中目标子字符串之前的字符串<br>是否不能匹配另一个表达式。|提取出不属于四川省的城市<br>`/(?<!四川省.*)([^省]*市)/`|

#### 验证用户名，不能包含特殊字符，长度要超过5个字符
```
const pattern = /^[^*%#$@]{5,}$/;

const result = pattern.test("Xiao$Ming"); // false
```
*分析：使用反选的进行匹配，`[^*%#$@]`表示除`*%#$@`之外的任何字符，然后使用`{m,n}`语法重复匹配，`{5,}`表示匹配前面元字符5次以上，`[^*%#$@]{5,}`整体表示：匹配除了这些特殊字符之外的任意字符5次以上。最后为了保证能完整匹配整个字符串，避免遗漏，需要在表达式开头加上`^`匹配字符串开头，在表达式最后加上`$`匹配字符串结尾。*

#### 验证密码，需要同时包含数组，大写字母，小写字母，特殊字符,并且长度不小于8位数<a id="password"></a>

```
const pattern = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[%#@$&]).{8,}$/;
const password = 'Aa12345678';

const result = pattern.test(password); // false
```
*分析：本例使用到正向肯定预查的**零宽特性**，零宽指的是：子表达式只会用来预判后面的字符，但不会消耗字符。比如给定字符串`hello world`，如果使用表达式`hello (world)(world)`是不能匹配成功的，因为子表达式`(world)`不零宽的，是消耗字符的，当匹配到第一个`(world)`的时候，字符就消耗完了，匹配到第二个`(world)`的时候，目标字符串的字符就不够了。如果使用表达式`hello (?=world)(?=world)`是匹配成功的，因为子表达式`(?=world)`是零宽的，是不消耗字符的，无论零宽表达式作用几次，目标字符串总会剩下`world`可用。*<br />
*本例用到了四个正向肯定预查子表达式，这四个表达式是依次跟在起始位置`^`后面，表示要匹配目标字符串的开始位置，但是匹配之前要预判一下目标字符串后面是否满足接下来的四个子表达式，预判成功后，才能目标字符串的匹配开头位置，此时这四个表达式完成了使命，控制权交给接下来的`.{8,}`子表达式。正是因为四个预查表达式不会消耗字符，所以用来做长度判断的子表达式`.{8,}`才能正常工作。*

#### 过滤出出生地，现居住地，工作地相同的人

```
const pattern = /出生于(.*?)，.*?现居于\1.*?工作地为\1/

const users = [
  "张三出生于北京市海淀区，今年28岁，现居于北京市海淀区中关村大街，工作地为北京市海淀区回龙观。",
  "李四出生于北京市海淀取，现居于北京市朝阳区东直门外大街，工作地为北京市昌平区中关村软件园。",
  "铁蛋出生于老虎沟，现居于老虎沟，工作地为老虎沟。"
]

const result = users.filter(user => pattern.test(user))
```
*分析：要求中的地址，在个体之间是允许不一样的，但是个体内部要一样。也就是说，对于同一个人，出生地确定了，那么居住地和工作地都要和出生地一样，才是符合条件的。这里使用到**反向引用**技术，反向引用指的是：在正则表达式中成功实现分组捕获之后，在后续的匹配中，直接引用之前的分组捕获的内容进行匹配。本例中的分组捕获是`(.*?)`，后续的反向引用则使用`\1`进行指定引用第一个分组。*<br />

反向引用的其他场景：

校验html标签是否配对，即开标签和闭标签名称需要一致
```
const pattern = /<([a-z]*?)>.*?<\/\1>/

pattern.test(<div>content</div>); // true
pattern.test(<div>content</a>);   // false

```

#### 给电话号码加上横线分割，格式化为xxx-xxxx-xxxx格式
```
const pattern = /(\d{3})(\d{4})(\d{4})/
const number = "13821261333"
const result = number.replace(pattern, "$1-$2-$3"); // "138-2126-1333"
```
*分析：这里用到的是分组捕获，正常情况下，表达式中一个小括号就是一个分组捕获，捕获之后贮按分组的前后顺序将分组内容保存在`RegExp`对象的`$1`至`$9`属性中，可直接通过`RegExp.$1`读取分组内容。在本例中，`String.prototype.replace`的第一个参数支持正则表达式，因此可以直接在第二个参数中使用简写的`$n`方式引用分组内容。*
 
