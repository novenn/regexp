---
layout: layout
---


不要搞又臭又长的字符匹配，不要搞乱七八糟的判断逻辑。搞来搞去，不如用正则。

你可以直接套用下面的一些经典案例，如果你想修改它们，你还需要了解一些[正则表达式的基础知识](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)。

#### 从URL中提取文件名

```
const pattern = /([^\/]*)$/;
const url = "https://www.test.com/to/path/regexp.html";

const result = url.match(pattern); // ['regexp.html', 'regexp.html', index: 29....]
```

*分析：URL中文件名的位置比较特殊，是最后一个`/`到字符串结尾的内容，因为文件名的格式要求比较宽松，可能包含的字符比较多，这里直接使用反选的方法，只要不包含`/`即可。`([^\/]*)`表示匹配除了`/`的任意字符，注意要加上`$`结尾匹配符，否则提取出来的不是最末尾位置的内容。*


#### 从一堆地址中提取出包含南京路的城市名<a id="forward"></a>
```
const pattern = /([^省]*市)(?=.*南京路)/
const address = [
  "四川省成都市龙泉驿区南京路318号",
  "广东省广州市荔湾区南京路14号大院",
  "天府三街海底捞店南京路厅",
  "湖北省南京路888号02栋408室",
  "上海市黄浦区河南中路与南京路交口",
  "南京路在贵阳市之后则匹配失败"
]

const result = address.map(item => item.match(pattern)?.[0])  // ['成都市', '广州市', '上海市']
                      .filter(item => item);              
```
*分析：本例使用到**正向肯定预查**，正向肯定预查指的是：在给定字符串中匹配一个目标子字符串，其成功的条件是必须同时匹配两个子表达式，一个是目标字符串子表达式，本例中的`([^省]*市)`，另一个是预查子表达式,本例中的`(?=.*南京路)`，并且预查表达式只能匹配目标字符串之后的字符。通俗的讲，就是匹配目标子表达式的同时要预判一下在给定字符串中目标子字符串之后的字符串是否匹配另一个表达式。*<br />
*那就有人说了，直接`([^省]*市).*南京路`不就能实现？用啥正向肯定预查，费劲巴拉。因为预查表达式是**零宽的**，查看[验证密码](#password)的例子*

引申内容：

- **正向肯定预查**：`(?=abc)`，匹配目标子表达式的同时要预判一下在给定字符串中目标子字符串之后的剩余字符串是否匹配另一个表达式。
- **正向否定预查**：`(?!abc)`，匹配目标子表达式的同时要预判一下在给定字符串中目标子字符串之后的剩余字符串是否不能匹配另一个表达式。
- **负向肯定预查**：`(?<=abc)`，匹配目标子表达式的同时要预判一下在给定字符串中目标子字符串之前的字符串是否匹配另一个表达式。
- **负向否定预查**：`(?<!abc)`，匹配目标子表达式的同时要预判一下在给定字符串中目标子字符串之前的字符串是否不能匹配另一个表达式。

#### 验证用户名，不能包含特殊字符，长度要超过5个字符
```
const pattern = /^[^*%#$@]{5,}$/;

const result = pattern.test("Xiao$Ming"); // false
```
*分析：使用反选的进行匹配，`[^*%#$@]`表示除`*%#$@`之外的任何字符，然后使用`{m,n}`语法重复匹配，`{5,}`表示匹配前面元字符5次以上，`[^*%#$@]{5,}`整体表示：匹配除了这些特殊字符之外的任意字符5次以上。最后为了保证能完整匹配整个字符串，避免遗漏，需要在表达式开头加上`^`匹配字符串开头，在表达式最后加上`$`匹配字符串结尾。*

#### 验证密码，需要同时包含数组，大写字母，小写字母，特殊字符,并且长度不小于8位数<a id="password"></a>

```
const pattern = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[%#@$&]).{8,}$/;
const password = 'Aa12345678';

const result = pattern.test(password); // false
```
*分析：本例使用到正向肯定预查的**零宽特性**，零宽指的是：子表达式只会用来预判后面的字符，但不会消耗字符。比如给定字符串`hello world`，如果使用表达式`hello (world)(world)`是不能匹配成功的，因为子表达式`(world)`不零宽的，是消耗字符的，当匹配到第一个`(world)`的时候，字符就消耗完了，匹配到第二个`(world)`的时候，目标字符串的字符就不够了。如果使用表达式`hello (?=world)(?=world)`是匹配成功的，因为子表达式`(?=world)`是零宽的，是不消耗字符的，无论零宽表达式作用几次，目标字符串总会剩下`world`可用。*<br />
*本例用到了四个正向肯定预查子表达式，这四个表达式是依次跟在起始位置`^`后面，表示要匹配目标字符串的开始位置，但是匹配之前要预判一下目标字符串后面是否满足接下来的四个子表达式，预判成功后，才能目标字符串的匹配开头位置，此时这四个表达式完成了使命，控制权交给接下来的`.{8,}`子表达式。正是因为四个预查表达式不会消耗字符，所以用来做长度判断的子表达式`.{8,}`才能正常工作。*


 
